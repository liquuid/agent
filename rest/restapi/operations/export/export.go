// Code generated by go-swagger; DO NOT EDIT.

package export

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	middleware "github.com/go-openapi/runtime/middleware"
)

// ExportHandlerFunc turns a function with the right signature into a export handler
type ExportHandlerFunc func(ExportParams) middleware.Responder

// Handle executing the request and returning a response
func (fn ExportHandlerFunc) Handle(params ExportParams) middleware.Responder {
	return fn(params)
}

// ExportHandler interface for that can handle valid export params
type ExportHandler interface {
	Handle(ExportParams) middleware.Responder
}

// NewExport creates a new http.Handler for the export operation
func NewExport(ctx *middleware.Context, handler ExportHandler) *Export {
	return &Export{Context: ctx, Handler: handler}
}

/*Export swagger:route POST /rest/v1/export/{container} export export

Export prepares an archive from a template in the `/mnt/lib/lxc/tmpdir/` path. This archive can be moved to another Subutai peer and deployed as ready-to-use template or uploaded to Subutai's global template repository to make it widely available for others to use.
Export consist of two steps if the target is a container: container promotion to template (see "promote" command) and packing the template into the archive. If already a template just the packing of the archive takes place.
Configuration values for template metadata parameters can be overridden on export, like the recommended container size when the template is cloned using `-s` option.

*/
type Export struct {
	Context *middleware.Context
	Handler ExportHandler
}

func (o *Export) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewExportParams()

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}
