// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	errors "github.com/go-openapi/errors"
	loads "github.com/go-openapi/loads"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	security "github.com/go-openapi/runtime/security"
	spec "github.com/go-openapi/spec"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/subutai-io/agent/rest/restapi/operations/attach"
	"github.com/subutai-io/agent/rest/restapi/operations/backup"
	"github.com/subutai-io/agent/rest/restapi/operations/batch"
	"github.com/subutai-io/agent/rest/restapi/operations/cleanup"
	"github.com/subutai-io/agent/rest/restapi/operations/clone"
	"github.com/subutai-io/agent/rest/restapi/operations/config"
	"github.com/subutai-io/agent/rest/restapi/operations/configuration"
	"github.com/subutai-io/agent/rest/restapi/operations/container"
	"github.com/subutai-io/agent/rest/restapi/operations/demote"
	"github.com/subutai-io/agent/rest/restapi/operations/destroy"
	"github.com/subutai-io/agent/rest/restapi/operations/export"
	"github.com/subutai-io/agent/rest/restapi/operations/hostname"
	"github.com/subutai-io/agent/rest/restapi/operations/import_operations"
	"github.com/subutai-io/agent/rest/restapi/operations/info"
	"github.com/subutai-io/agent/rest/restapi/operations/list"
	"github.com/subutai-io/agent/rest/restapi/operations/metrics"
	"github.com/subutai-io/agent/rest/restapi/operations/p2p"
	"github.com/subutai-io/agent/rest/restapi/operations/promote"
	"github.com/subutai-io/agent/rest/restapi/operations/proxy"
	"github.com/subutai-io/agent/rest/restapi/operations/quota"
	"github.com/subutai-io/agent/rest/restapi/operations/rename"
	"github.com/subutai-io/agent/rest/restapi/operations/resource_host"
	"github.com/subutai-io/agent/rest/restapi/operations/restore"
	"github.com/subutai-io/agent/rest/restapi/operations/start"
	"github.com/subutai-io/agent/rest/restapi/operations/stop"
	"github.com/subutai-io/agent/rest/restapi/operations/tunnel"
	"github.com/subutai-io/agent/rest/restapi/operations/update"
	"github.com/subutai-io/agent/rest/restapi/operations/vxlan"
)

// NewAgentAPI creates a new Agent instance
func NewAgentAPI(spec *loads.Document) *AgentAPI {
	return &AgentAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		ServerShutdown:      func() {},
		spec:                spec,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,
		JSONConsumer:        runtime.JSONConsumer(),
		JSONProducer:        runtime.JSONProducer(),
		AttachAttachHandler: attach.AttachHandlerFunc(func(params attach.AttachParams) middleware.Responder {
			return middleware.NotImplemented("operation AttachAttach has not yet been implemented")
		}),
		BackupBackupContainerHandler: backup.BackupContainerHandlerFunc(func(params backup.BackupContainerParams) middleware.Responder {
			return middleware.NotImplemented("operation BackupBackupContainer has not yet been implemented")
		}),
		BatchBatchHandler: batch.BatchHandlerFunc(func(params batch.BatchParams) middleware.Responder {
			return middleware.NotImplemented("operation BatchBatch has not yet been implemented")
		}),
		CleanupCleanupHandler: cleanup.CleanupHandlerFunc(func(params cleanup.CleanupParams) middleware.Responder {
			return middleware.NotImplemented("operation CleanupCleanup has not yet been implemented")
		}),
		ListCliListHandler: list.CliListHandlerFunc(func(params list.CliListParams) middleware.Responder {
			return middleware.NotImplemented("operation ListCliList has not yet been implemented")
		}),
		CloneCloneHandler: clone.CloneHandlerFunc(func(params clone.CloneParams) middleware.Responder {
			return middleware.NotImplemented("operation CloneClone has not yet been implemented")
		}),
		ConfigurationConfigHandler: configuration.ConfigHandlerFunc(func(params configuration.ConfigParams) middleware.Responder {
			return middleware.NotImplemented("operation ConfigurationConfig has not yet been implemented")
		}),
		DemoteDemoteHandler: demote.DemoteHandlerFunc(func(params demote.DemoteParams) middleware.Responder {
			return middleware.NotImplemented("operation DemoteDemote has not yet been implemented")
		}),
		DestroyDestroyHandler: destroy.DestroyHandlerFunc(func(params destroy.DestroyParams) middleware.Responder {
			return middleware.NotImplemented("operation DestroyDestroy has not yet been implemented")
		}),
		ConfigDestroyEntryHandler: config.DestroyEntryHandlerFunc(func(params config.DestroyEntryParams) middleware.Responder {
			return middleware.NotImplemented("operation ConfigDestroyEntry has not yet been implemented")
		}),
		ContainerDestroyOneHandler: container.DestroyOneHandlerFunc(func(params container.DestroyOneParams) middleware.Responder {
			return middleware.NotImplemented("operation ContainerDestroyOne has not yet been implemented")
		}),
		ExportExportHandler: export.ExportHandlerFunc(func(params export.ExportParams) middleware.Responder {
			return middleware.NotImplemented("operation ExportExport has not yet been implemented")
		}),
		ContainerGetContainerInfoHandler: container.GetContainerInfoHandlerFunc(func(params container.GetContainerInfoParams) middleware.Responder {
			return middleware.NotImplemented("operation ContainerGetContainerInfo has not yet been implemented")
		}),
		HostnameHostnameHandler: hostname.HostnameHandlerFunc(func(params hostname.HostnameParams) middleware.Responder {
			return middleware.NotImplemented("operation HostnameHostname has not yet been implemented")
		}),
		ImportOperationsImportHandler: import_operations.ImportHandlerFunc(func(params import_operations.ImportParams) middleware.Responder {
			return middleware.NotImplemented("operation ImportOperationsImport has not yet been implemented")
		}),
		InfoInfoHandler: info.InfoHandlerFunc(func(params info.InfoParams) middleware.Responder {
			return middleware.NotImplemented("operation InfoInfo has not yet been implemented")
		}),
		MetricsMetricsHandler: metrics.MetricsHandlerFunc(func(params metrics.MetricsParams) middleware.Responder {
			return middleware.NotImplemented("operation MetricsMetrics has not yet been implemented")
		}),
		P2pP2pCreateHandler: p2p.P2pCreateHandlerFunc(func(params p2p.P2pCreateParams) middleware.Responder {
			return middleware.NotImplemented("operation P2pP2pCreate has not yet been implemented")
		}),
		P2pP2pDeleteHandler: p2p.P2pDeleteHandlerFunc(func(params p2p.P2pDeleteParams) middleware.Responder {
			return middleware.NotImplemented("operation P2pP2pDelete has not yet been implemented")
		}),
		P2pP2pListHandler: p2p.P2pListHandlerFunc(func(params p2p.P2pListParams) middleware.Responder {
			return middleware.NotImplemented("operation P2pP2pList has not yet been implemented")
		}),
		P2pP2pUpdateHandler: p2p.P2pUpdateHandlerFunc(func(params p2p.P2pUpdateParams) middleware.Responder {
			return middleware.NotImplemented("operation P2pP2pUpdate has not yet been implemented")
		}),
		PromotePromoteHandler: promote.PromoteHandlerFunc(func(params promote.PromoteParams) middleware.Responder {
			return middleware.NotImplemented("operation PromotePromote has not yet been implemented")
		}),
		ProxyProxyCheckHandler: proxy.ProxyCheckHandlerFunc(func(params proxy.ProxyCheckParams) middleware.Responder {
			return middleware.NotImplemented("operation ProxyProxyCheck has not yet been implemented")
		}),
		ProxyProxyCreateHandler: proxy.ProxyCreateHandlerFunc(func(params proxy.ProxyCreateParams) middleware.Responder {
			return middleware.NotImplemented("operation ProxyProxyCreate has not yet been implemented")
		}),
		ProxyProxyDeleteHandler: proxy.ProxyDeleteHandlerFunc(func(params proxy.ProxyDeleteParams) middleware.Responder {
			return middleware.NotImplemented("operation ProxyProxyDelete has not yet been implemented")
		}),
		QuotaQuotaHandler: quota.QuotaHandlerFunc(func(params quota.QuotaParams) middleware.Responder {
			return middleware.NotImplemented("operation QuotaQuota has not yet been implemented")
		}),
		RenameRenameHandler: rename.RenameHandlerFunc(func(params rename.RenameParams) middleware.Responder {
			return middleware.NotImplemented("operation RenameRename has not yet been implemented")
		}),
		RestoreRestoreHandler: restore.RestoreHandlerFunc(func(params restore.RestoreParams) middleware.Responder {
			return middleware.NotImplemented("operation RestoreRestore has not yet been implemented")
		}),
		ResourceHostRhIDHandler: resource_host.RhIDHandlerFunc(func(params resource_host.RhIDParams) middleware.Responder {
			return middleware.NotImplemented("operation ResourceHostRhID has not yet been implemented")
		}),
		StartStartHandler: start.StartHandlerFunc(func(params start.StartParams) middleware.Responder {
			return middleware.NotImplemented("operation StartStart has not yet been implemented")
		}),
		StopStopHandler: stop.StopHandlerFunc(func(params stop.StopParams) middleware.Responder {
			return middleware.NotImplemented("operation StopStop has not yet been implemented")
		}),
		TunnelTunnelAddHandler: tunnel.TunnelAddHandlerFunc(func(params tunnel.TunnelAddParams) middleware.Responder {
			return middleware.NotImplemented("operation TunnelTunnelAdd has not yet been implemented")
		}),
		TunnelTunnelCheckHandler: tunnel.TunnelCheckHandlerFunc(func(params tunnel.TunnelCheckParams) middleware.Responder {
			return middleware.NotImplemented("operation TunnelTunnelCheck has not yet been implemented")
		}),
		TunnelTunnelDeleteHandler: tunnel.TunnelDeleteHandlerFunc(func(params tunnel.TunnelDeleteParams) middleware.Responder {
			return middleware.NotImplemented("operation TunnelTunnelDelete has not yet been implemented")
		}),
		TunnelTunnelListHandler: tunnel.TunnelListHandlerFunc(func(params tunnel.TunnelListParams) middleware.Responder {
			return middleware.NotImplemented("operation TunnelTunnelList has not yet been implemented")
		}),
		UpdateUpdateHandler: update.UpdateHandlerFunc(func(params update.UpdateParams) middleware.Responder {
			return middleware.NotImplemented("operation UpdateUpdate has not yet been implemented")
		}),
		VxlanVxlanCreateHandler: vxlan.VxlanCreateHandlerFunc(func(params vxlan.VxlanCreateParams) middleware.Responder {
			return middleware.NotImplemented("operation VxlanVxlanCreate has not yet been implemented")
		}),
		VxlanVxlanDeleteHandler: vxlan.VxlanDeleteHandlerFunc(func(params vxlan.VxlanDeleteParams) middleware.Responder {
			return middleware.NotImplemented("operation VxlanVxlanDelete has not yet been implemented")
		}),
		VxlanVxlanListHandler: vxlan.VxlanListHandlerFunc(func(params vxlan.VxlanListParams) middleware.Responder {
			return middleware.NotImplemented("operation VxlanVxlanList has not yet been implemented")
		}),
	}
}

/*AgentAPI API to handle agent
 */
type AgentAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for a "application/json" mime type
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for a "application/json" mime type
	JSONProducer runtime.Producer

	// AttachAttachHandler sets the operation handler for the attach operation
	AttachAttachHandler attach.AttachHandler
	// BackupBackupContainerHandler sets the operation handler for the backup container operation
	BackupBackupContainerHandler backup.BackupContainerHandler
	// BatchBatchHandler sets the operation handler for the batch operation
	BatchBatchHandler batch.BatchHandler
	// CleanupCleanupHandler sets the operation handler for the cleanup operation
	CleanupCleanupHandler cleanup.CleanupHandler
	// ListCliListHandler sets the operation handler for the cli list operation
	ListCliListHandler list.CliListHandler
	// CloneCloneHandler sets the operation handler for the clone operation
	CloneCloneHandler clone.CloneHandler
	// ConfigurationConfigHandler sets the operation handler for the config operation
	ConfigurationConfigHandler configuration.ConfigHandler
	// DemoteDemoteHandler sets the operation handler for the demote operation
	DemoteDemoteHandler demote.DemoteHandler
	// DestroyDestroyHandler sets the operation handler for the destroy operation
	DestroyDestroyHandler destroy.DestroyHandler
	// ConfigDestroyEntryHandler sets the operation handler for the destroy entry operation
	ConfigDestroyEntryHandler config.DestroyEntryHandler
	// ContainerDestroyOneHandler sets the operation handler for the destroy one operation
	ContainerDestroyOneHandler container.DestroyOneHandler
	// ExportExportHandler sets the operation handler for the export operation
	ExportExportHandler export.ExportHandler
	// ContainerGetContainerInfoHandler sets the operation handler for the get container info operation
	ContainerGetContainerInfoHandler container.GetContainerInfoHandler
	// HostnameHostnameHandler sets the operation handler for the hostname operation
	HostnameHostnameHandler hostname.HostnameHandler
	// ImportOperationsImportHandler sets the operation handler for the import operation
	ImportOperationsImportHandler import_operations.ImportHandler
	// InfoInfoHandler sets the operation handler for the info operation
	InfoInfoHandler info.InfoHandler
	// MetricsMetricsHandler sets the operation handler for the metrics operation
	MetricsMetricsHandler metrics.MetricsHandler
	// P2pP2pCreateHandler sets the operation handler for the p2p create operation
	P2pP2pCreateHandler p2p.P2pCreateHandler
	// P2pP2pDeleteHandler sets the operation handler for the p2p delete operation
	P2pP2pDeleteHandler p2p.P2pDeleteHandler
	// P2pP2pListHandler sets the operation handler for the p2p list operation
	P2pP2pListHandler p2p.P2pListHandler
	// P2pP2pUpdateHandler sets the operation handler for the p2p update operation
	P2pP2pUpdateHandler p2p.P2pUpdateHandler
	// PromotePromoteHandler sets the operation handler for the promote operation
	PromotePromoteHandler promote.PromoteHandler
	// ProxyProxyCheckHandler sets the operation handler for the proxy check operation
	ProxyProxyCheckHandler proxy.ProxyCheckHandler
	// ProxyProxyCreateHandler sets the operation handler for the proxy create operation
	ProxyProxyCreateHandler proxy.ProxyCreateHandler
	// ProxyProxyDeleteHandler sets the operation handler for the proxy delete operation
	ProxyProxyDeleteHandler proxy.ProxyDeleteHandler
	// QuotaQuotaHandler sets the operation handler for the quota operation
	QuotaQuotaHandler quota.QuotaHandler
	// RenameRenameHandler sets the operation handler for the rename operation
	RenameRenameHandler rename.RenameHandler
	// RestoreRestoreHandler sets the operation handler for the restore operation
	RestoreRestoreHandler restore.RestoreHandler
	// ResourceHostRhIDHandler sets the operation handler for the rh ID operation
	ResourceHostRhIDHandler resource_host.RhIDHandler
	// StartStartHandler sets the operation handler for the start operation
	StartStartHandler start.StartHandler
	// StopStopHandler sets the operation handler for the stop operation
	StopStopHandler stop.StopHandler
	// TunnelTunnelAddHandler sets the operation handler for the tunnel add operation
	TunnelTunnelAddHandler tunnel.TunnelAddHandler
	// TunnelTunnelCheckHandler sets the operation handler for the tunnel check operation
	TunnelTunnelCheckHandler tunnel.TunnelCheckHandler
	// TunnelTunnelDeleteHandler sets the operation handler for the tunnel delete operation
	TunnelTunnelDeleteHandler tunnel.TunnelDeleteHandler
	// TunnelTunnelListHandler sets the operation handler for the tunnel list operation
	TunnelTunnelListHandler tunnel.TunnelListHandler
	// UpdateUpdateHandler sets the operation handler for the update operation
	UpdateUpdateHandler update.UpdateHandler
	// VxlanVxlanCreateHandler sets the operation handler for the vxlan create operation
	VxlanVxlanCreateHandler vxlan.VxlanCreateHandler
	// VxlanVxlanDeleteHandler sets the operation handler for the vxlan delete operation
	VxlanVxlanDeleteHandler vxlan.VxlanDeleteHandler
	// VxlanVxlanListHandler sets the operation handler for the vxlan list operation
	VxlanVxlanListHandler vxlan.VxlanListHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// SetDefaultProduces sets the default produces media type
func (o *AgentAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *AgentAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *AgentAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *AgentAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *AgentAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *AgentAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *AgentAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the AgentAPI
func (o *AgentAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.AttachAttachHandler == nil {
		unregistered = append(unregistered, "attach.AttachHandler")
	}

	if o.BackupBackupContainerHandler == nil {
		unregistered = append(unregistered, "backup.BackupContainerHandler")
	}

	if o.BatchBatchHandler == nil {
		unregistered = append(unregistered, "batch.BatchHandler")
	}

	if o.CleanupCleanupHandler == nil {
		unregistered = append(unregistered, "cleanup.CleanupHandler")
	}

	if o.ListCliListHandler == nil {
		unregistered = append(unregistered, "list.CliListHandler")
	}

	if o.CloneCloneHandler == nil {
		unregistered = append(unregistered, "clone.CloneHandler")
	}

	if o.ConfigurationConfigHandler == nil {
		unregistered = append(unregistered, "configuration.ConfigHandler")
	}

	if o.DemoteDemoteHandler == nil {
		unregistered = append(unregistered, "demote.DemoteHandler")
	}

	if o.DestroyDestroyHandler == nil {
		unregistered = append(unregistered, "destroy.DestroyHandler")
	}

	if o.ConfigDestroyEntryHandler == nil {
		unregistered = append(unregistered, "config.DestroyEntryHandler")
	}

	if o.ContainerDestroyOneHandler == nil {
		unregistered = append(unregistered, "container.DestroyOneHandler")
	}

	if o.ExportExportHandler == nil {
		unregistered = append(unregistered, "export.ExportHandler")
	}

	if o.ContainerGetContainerInfoHandler == nil {
		unregistered = append(unregistered, "container.GetContainerInfoHandler")
	}

	if o.HostnameHostnameHandler == nil {
		unregistered = append(unregistered, "hostname.HostnameHandler")
	}

	if o.ImportOperationsImportHandler == nil {
		unregistered = append(unregistered, "import_operations.ImportHandler")
	}

	if o.InfoInfoHandler == nil {
		unregistered = append(unregistered, "info.InfoHandler")
	}

	if o.MetricsMetricsHandler == nil {
		unregistered = append(unregistered, "metrics.MetricsHandler")
	}

	if o.P2pP2pCreateHandler == nil {
		unregistered = append(unregistered, "p2p.P2pCreateHandler")
	}

	if o.P2pP2pDeleteHandler == nil {
		unregistered = append(unregistered, "p2p.P2pDeleteHandler")
	}

	if o.P2pP2pListHandler == nil {
		unregistered = append(unregistered, "p2p.P2pListHandler")
	}

	if o.P2pP2pUpdateHandler == nil {
		unregistered = append(unregistered, "p2p.P2pUpdateHandler")
	}

	if o.PromotePromoteHandler == nil {
		unregistered = append(unregistered, "promote.PromoteHandler")
	}

	if o.ProxyProxyCheckHandler == nil {
		unregistered = append(unregistered, "proxy.ProxyCheckHandler")
	}

	if o.ProxyProxyCreateHandler == nil {
		unregistered = append(unregistered, "proxy.ProxyCreateHandler")
	}

	if o.ProxyProxyDeleteHandler == nil {
		unregistered = append(unregistered, "proxy.ProxyDeleteHandler")
	}

	if o.QuotaQuotaHandler == nil {
		unregistered = append(unregistered, "quota.QuotaHandler")
	}

	if o.RenameRenameHandler == nil {
		unregistered = append(unregistered, "rename.RenameHandler")
	}

	if o.RestoreRestoreHandler == nil {
		unregistered = append(unregistered, "restore.RestoreHandler")
	}

	if o.ResourceHostRhIDHandler == nil {
		unregistered = append(unregistered, "resource_host.RhIDHandler")
	}

	if o.StartStartHandler == nil {
		unregistered = append(unregistered, "start.StartHandler")
	}

	if o.StopStopHandler == nil {
		unregistered = append(unregistered, "stop.StopHandler")
	}

	if o.TunnelTunnelAddHandler == nil {
		unregistered = append(unregistered, "tunnel.TunnelAddHandler")
	}

	if o.TunnelTunnelCheckHandler == nil {
		unregistered = append(unregistered, "tunnel.TunnelCheckHandler")
	}

	if o.TunnelTunnelDeleteHandler == nil {
		unregistered = append(unregistered, "tunnel.TunnelDeleteHandler")
	}

	if o.TunnelTunnelListHandler == nil {
		unregistered = append(unregistered, "tunnel.TunnelListHandler")
	}

	if o.UpdateUpdateHandler == nil {
		unregistered = append(unregistered, "update.UpdateHandler")
	}

	if o.VxlanVxlanCreateHandler == nil {
		unregistered = append(unregistered, "vxlan.VxlanCreateHandler")
	}

	if o.VxlanVxlanDeleteHandler == nil {
		unregistered = append(unregistered, "vxlan.VxlanDeleteHandler")
	}

	if o.VxlanVxlanListHandler == nil {
		unregistered = append(unregistered, "vxlan.VxlanListHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *AgentAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *AgentAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {

	return nil

}

// Authorizer returns the registered authorizer
func (o *AgentAPI) Authorizer() runtime.Authorizer {

	return nil

}

// ConsumersFor gets the consumers for the specified media types
func (o *AgentAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {

	result := make(map[string]runtime.Consumer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONConsumer

		}
	}
	return result

}

// ProducersFor gets the producers for the specified media types
func (o *AgentAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {

	result := make(map[string]runtime.Producer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONProducer

		}
	}
	return result

}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *AgentAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the agent API
func (o *AgentAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *AgentAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened

	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/attach/{container}"] = attach.NewAttach(o.context, o.AttachAttachHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/backup/{name}"] = backup.NewBackupContainer(o.context, o.BackupBackupContainerHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/batch"] = batch.NewBatch(o.context, o.BatchBatchHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/cleanup"] = cleanup.NewCleanup(o.context, o.CleanupCleanupHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/list"] = list.NewCliList(o.context, o.ListCliListHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/clone/{parent}/{child}"] = clone.NewClone(o.context, o.CloneCloneHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/config"] = configuration.NewConfig(o.context, o.ConfigurationConfigHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/demote/{container}"] = demote.NewDemote(o.context, o.DemoteDemoteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/destroy/{ID}"] = destroy.NewDestroy(o.context, o.DestroyDestroyHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/config"] = config.NewDestroyEntry(o.context, o.ConfigDestroyEntryHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/container/{name}"] = container.NewDestroyOne(o.context, o.ContainerDestroyOneHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/export/{container}"] = export.NewExport(o.context, o.ExportExportHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/container/{name}"] = container.NewGetContainerInfo(o.context, o.ContainerGetContainerInfoHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/hostname/{container}/{name}"] = hostname.NewHostname(o.context, o.HostnameHostnameHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/import/{container}"] = import_operations.NewImport(o.context, o.ImportOperationsImportHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/info"] = info.NewInfo(o.context, o.InfoInfoHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/metrics"] = metrics.NewMetrics(o.context, o.MetricsMetricsHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/p2p"] = p2p.NewP2pCreate(o.context, o.P2pP2pCreateHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/p2p"] = p2p.NewP2pDelete(o.context, o.P2pP2pDeleteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/p2p"] = p2p.NewP2pList(o.context, o.P2pP2pListHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/rest/v1/p2p"] = p2p.NewP2pUpdate(o.context, o.P2pP2pUpdateHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/promote/{container}"] = promote.NewPromote(o.context, o.PromotePromoteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/proxy"] = proxy.NewProxyCheck(o.context, o.ProxyProxyCheckHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/proxy"] = proxy.NewProxyCreate(o.context, o.ProxyProxyCreateHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/proxy"] = proxy.NewProxyDelete(o.context, o.ProxyProxyDeleteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/quota"] = quota.NewQuota(o.context, o.QuotaQuotaHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/rename/{source}/{newname}"] = rename.NewRename(o.context, o.RenameRenameHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/restore/{container}"] = restore.NewRestore(o.context, o.RestoreRestoreHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/rh/id"] = resource_host.NewRhID(o.context, o.ResourceHostRhIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/start/{container}"] = start.NewStart(o.context, o.StartStartHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/stop/{container}"] = stop.NewStop(o.context, o.StopStopHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/tunnel/{socket}"] = tunnel.NewTunnelAdd(o.context, o.TunnelTunnelAddHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/tunnel/check"] = tunnel.NewTunnelCheck(o.context, o.TunnelTunnelCheckHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/tunnel/{socket}"] = tunnel.NewTunnelDelete(o.context, o.TunnelTunnelDeleteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/tunnel/list"] = tunnel.NewTunnelList(o.context, o.TunnelTunnelListHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/update/{container}"] = update.NewUpdate(o.context, o.UpdateUpdateHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/rest/v1/vxlan/{tunnel}"] = vxlan.NewVxlanCreate(o.context, o.VxlanVxlanCreateHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/rest/v1/vxlan/{iface}"] = vxlan.NewVxlanDelete(o.context, o.VxlanVxlanDeleteHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/rest/v1/vxlan/list"] = vxlan.NewVxlanList(o.context, o.VxlanVxlanListHandler)

}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *AgentAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middelware as you see fit
func (o *AgentAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}
